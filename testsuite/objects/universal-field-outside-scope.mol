
//!should_fail
//!err .*AssignError.*
//!err .*

class Assign<'item> {
    let mut thing: 'item

    fn new(self) { }

    fn assign(self, t: 'item) {
        // This is allowed because 'time is defined in the class definition, so it's in scope
        self.thing = t
    }
}

let assign = new Assign<String>()

// This fails because it is out of scope, even though the field can be accessed
assign.thing = "fail"

